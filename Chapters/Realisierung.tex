
%*****************************************
\chapter{Realisierung}\label{ch:Realisierung}
%*****************************************
    Bei der Realisierung einer AIDS müssen wie in~\autoref{ch:Grundlagen} beschrieben zwei Phasen durchlaufen werden.
    Die Trainingsphase und die Testphase.
    Diesen beiden Phasen liegt allerdings schon ein präparierter Datensatz und die Definition der exakten Eingaben und Ausgaben des \ac{LSTM} zu Grunde. 
    Welche Datensätze überhaupt in Frage kommen wurde bereits in~\autoref{sec:Datensatz} untersucht.
    Wie dieser weiterverarbeitet, für das \ac{LSTM} vorbereitet wird und welche Informationen neben dem Namen des System Calls verwendet werden kann, 
    soll in~\autoref{sec:Preprocessing} betrachtet werden.
    Zuvor in~\autoref{sec:Tools} werden verschiedene Tools betrachtet, die für die Vorverarbeitung und weitere Implementierungen nötig sind.
    Der eigentliche Algorithmus, also das Finden von Anomalien in den Daten wird dann im~\autoref{sec:Algorithmus} beschrieben.
    Nachdem so also der verarbeitende Teil betrachtet wurde, soll in~\autoref{sec:StrukExp} die Strukturierung der Experimente präsentiert werden.
    Diese Strukturierung hat zum Ziel früh wenig vielversprechende Konfigurationen auszuschließen um ressourcenschonend Auswertungen durchzuführen.
    Speziell die Ressource Zeit, wie sich später zeigen wird, ist dabei im Rahmen dieser Arbeit eine Entscheidende.
    Abschließen soll dieses Kapitel dann in~\autoref{sec:Metriken} die Untersuchung von Metriken, welche dann für die Auswertung der Experimente benötigt wird.



    \section{Verwendete Tools}\label{sec:Tools}
        Tensorflow Keras
        Rechencluster clara
        sysdig

    \section{Vorverarbeitung}\label{sec:Preprocessing}
        %In dem kommenden Abschnitt~\ref{sec:struktur} wird die erste Vorverarbeitung des Datensatzes vorgestellt.
        Im kommenden Abschnitt~\ref{sec:syscalldarstellung} soll untersucht werden, welche Darstellungsformen für die eigentlichen System Calls interessant und sinnvoll sind.
        In dieser Arbeit werden die System Call Daten als Datenstream betrachtet.
        Weshalb in Abschnitt~\ref{sec:streamdarstellung} die Frage geprüft, wie dieser für das \ac{LSTM} dargestellt wird.
        Ein weiterer wichtiger Teil der Arbeit besteht darin, zu klären welche Metadaten neben dem Namen des System Calls noch verwendet werden können,
        um die Erkennungsrate zu erhöhen, bzw.\ die Fehlerrate zu verringern.
        Die Frage welche Informationen dafür verwendet werden können und wie diese dargestellt werden, soll in Abschnitt~\ref{sec:Meta}

        %\subsection{Vorverarbeitung des Datensatzes}\label{sec:struktur}
            %Gegeben 10 szenarien die aus bekannten CVEs bestehen.\
            %mit ca. 1000 files durschnittlich 45sec
            %in runs.csv genauere beschreibung files mit label und zeitangabe falls exploit
            %falls kein exploit dann exploit start time -1
            %keine dauer des exploits also ende nicht bekannt 
            %nicht systemcall genau start des angriffs angegeben 
            %führe puffer ein, da angegebener Zeitpunkt ungenau, sodass auch wirklich jeder angriff nach exploit start time
            %alles nach dem angrffszeitpunkt muss als anomalie gewertet werden, auch wenn angriff evtl noch nicht gestartet hat oder schon vorbei.
            %%TODO Quadranten
            %filtern von switch statements in Datensatz weil keine system calls
            %nur schließende syscalls keine öffnenden.
            %Muss wie in~\ref{sec:syscalls} beschrieben immer beide geben.
            %Schließende interessant, da auch Rückgabewerte betrachtet werden können

        \subsection{Wie wird ein System Call dargestellt?}\label{sec:syscalldarstellung}
            Neuronale Netze benötigen numerische werte deswegen Umwandlung von Namen der System Calls. 
            Eine einfache Kodierung dieser Strings bestünde darin die System Calls in Integer Werte umzuwandeln.
            Allerdings entstehen dabei künstliche Zusammenhänge und Ordnungen, welche für den Lernvorgang unvorteilhaft sein können~\cite{NEURALBISHOP1995}.
            Werden die System Calls als kategorische Daten betrachtet bietet sich das für neuronale Netze typische \ac{OHE} an.
            \paragraph{One-Hot-Encoding}
                Für die Darstellung eines System Calls mit dem \ac{OHE}, muss zunächst die Anzahl $n$ der unterschiedlichen System Calls ermittelt werden.
                Der System Call $sc_i$ aus der Menge der möglichen System Calls $ SC = \{sc_1,sc_2,\dots,sc_n\}$ 
                wird dann als Bit-Vektor $v_i$ der Länge $n$ kodiert.
                Dabei nehmen alle Stellen bis auf $i$ den Wert $0$ an und dort den Wert $1$.
                So wird aus dem System Call \textit{open} aus der Menge $SC = \{open, close, read\}$ der Vektor $v_1 = (1, 0, 0)$
                Da die Anzahl der möglichen System Calls und damit auch $n$ begrenzt ist, scheint diese Darstellung für einen System Call denkbar.
                Allerdings bringt sie auch zwei neue Probleme mit sich.
                Zum einen führt das \ac{OHE} eines System Calls bei großem $n$ zu einem langen und spärlich besetzten Vektor $v_i$.
                Gerade bei neuronalen Netzen führt das zu längeren Rechenzeiten.
                Und der neu gewonnen Vorteil, dass keine künstlichen Ordnungen vorhanden ist birgt den Nachteil, dass tatsächlich ebenso vorhandene Zusammenhänge verloren gehen.
                So besteht mindestens ein semantischer Zusammenhang zwischen \textit{open} und \textit{close} in der englischen Sprache, dieser ist in dem \ac{OHE} verloren gegangen. 
                Optimaler Weise gilt es also eine Darstellung zu finden die kurz ist und in der nur gewollte Ordnungen vorhanden sind.
                In der \ac{NLP} gilt es ähnliche Probleme durch die Darstellungen der Wörter zu lösen, zum Beispiel mit dem \ac{W2V} Verfahren.

            \paragraph{Word2Vec}
                Das \ac{W2V} Verfahren ist ein auf feedforward neuronalen Netzen basierender Ansatz, welcher häufig in der \ac{NLP} eingesetzt wird~\cite{W2VAYYADEVARA2018}.
                Dabei werden Wörter aus einem gegebenen Satz an möglichen Wörtern anhand eines Trainingsdatensatzes in dichte Vektoren $v$ fester Länge $embed\_size$ kodiert beziehungsweise \textit{embedded}\marginpar{zu dt.\ eingebettet}.
                Ziel des von~\cite{W2VMIKOLOV2013} eingeführten \ac{W2V} Verfahrens ist es eine Dimensionsreduktion durchzuführen, bei welcher möglichst viel Kontextinformationen erhalten bleiben.
                So sollen also die Vektordarstellungen von ähnlichen Wörtern ebenso ähnlich sein.
                Dies wird erreicht, indem Worte für das Erstellen der Kodierung nicht einzeln betrachtet werden, sondern immer in einem Kontext.
                Es wird angenommen, dass Wörter die häufig in einem ähnlichen Kontext auftreten, auch ähnlich sind.
                Wie umfangreich dieser Kontext für jedes Wort sein soll, wird mit der Fenstergröße $window\_length$ festgelegt.

                In der Trainingsphase gibt es zwei verschiedene Ansätze, zum einen das \textit{Continuous Bag-Of-Words},
                dabei wird versucht eine Vorhersage über ein Wort anhand des Kontextes zu machen.
                Hingegen wird unter Verwendung von \textit{Skip-gram}, eine Vorhersage des Kontextes aufgrund des Wortes vorgenommen.~\cite{EMBEDDINGPILEHVAR2020}

                Schwierigkeiten wie das häufige auftreten von Wörtern in der englischen Sprache wie \textit{the}, treten in der System Call Domäne nicht auf.
                Die Vorteile der dichtbesetzten und dimensionsreduzierten Vektoren machen sich auch bereits~\cite{IDSTHREADGRIMMER2021} in der anomaliebasierten \ac{HIDS} mit System Calls zu nutzen.
                Dieses Embedding wird auch im Folgenden verwendet.
                
            Neben den eigentlichen Namen der System Call enthalten tatsächliche System Calls wie in \autoref{sec:syscalls} beschrieben noch wesentlich mehr Informationen.
            Wie zumindest Teile dieser die Embeddings der System Calls erweitern können soll im folgenden Abschnitt untersucht werden.

            \subsection{Wie können weitere System Call Informationen dargestellt werden?}\label{sec:Meta}

                Wie zusätzliche Informationen der System Calls genutzt werden können ist auch Gegenstand bestehender Forschung.
                In \autoref{sec:related_sys_arg} wurden die verschiedenen bestehenden Ansätze untersucht.
                Im Folgenden soll es speziell darum gehen neue Darstellungsformen der System Call Argumente zu finden.
                Dabei soll noch einmal kurz auf die in \autoref{sec:syscalls} besprochenen Grundlagen zurückgegriffen werden um einen ersten Anhaltspunkt für wichtige Informationsquellen zu finden.

                Um die Unterscheidung von Normalverhalten und einer Anomalie zu erleichtern, müssen Faktoren betrachtet werden, welche sensibel auf eine Veränderung des Normalverhaltens reagieren.
                Gleichzeitig sollen dabei aber nicht einzelne Angriffe genutzt werden um diese Faktoren zu ermitteln.
                Denn dabei besteht die Gefahr Signaturen einzelner Angriffe abbilden zu wollen, was wie in \autoref{sec:Datenanalyse} ungewollte Nachteile hat.
                Ziel dieses Abschnitts ist es die Überlegungen und Umsetzungen von zwei Verfahren zur Darstellung von zusätzlichen System Call Informationen zu präsentieren.

            \paragraph{Zeitliche Abstände von System Calls}

                Wie bereits in \autoref{sec:related_sys_arg} beschrieben verwenden Lucket et al.~\cite{TIMINGLUCKETT2016} die Timing-Information von System Calls für das Aufspüren von Rootkits.
                In diesem Abschnitt wird diese Idee wieder aufgegriffen.
                Die Grundidee besteht darin, dass durch ein Angriffsverhalten eine zumindest kurzzeitige Veränderung im Timing der auftretenden System Calls eintritt.
                Dabei gelten System Calls in diesem Ansatz nur als aufeinanderfolgend, sofern sie auch aus dem selben Thread stammen.
                Eine genauere Erläuterung dazu erfolgt in \autoref{sec:streamdarstellung}.
                Um den Unterschied in den Normaldaten und Angriffsdaten zu untersuchen wurden in \autoref{fig:time_delta} die zeitlichen Abstände zwischen aufeinanderfolgenden System Calls aus dem Bruteforce und dem CVE-2019-5418 Szenario des \ac{LIDDS} geplottet.
                In Blau sind die Abstände der System Calls während des Normalverhaltens eingetragen und in Rot die des Normalverhaltens mit zusätzlichen Angriffsverhalten.
                Im rechten Plot kein sichtlicher Unterschied zwischen Angriffsverhalten und dem Normalverhalten zu erkennen.
                Der in diesem Szenario durchgeführte Angriff scheint nicht zu einer Abweichung der Zeitabstände zwischen System Calls zu führen.
                Im linken Plot hingegen ist eine Abweichung im Bereich ab ca. $0.05*10^{6}$\textit{ns} zu erkennen.

                %Wie in \autoref{sec:related_no_arg} beschrieben können Verfahren die keine weiteren Parameter verwenden umgangen werden, indem weitere System Calls eingefügt werden~\cite{Syscallseqexploit1}.
                \begin{figure}
                    \centering
                    \includegraphics[width=\textwidth]{images/CVE-2012--Test-data-time_delta.eps}
                    \caption{Dargestellt ist der zeitliche Abstand zwischen zwei System Calls aus dem selben Thread.
                             Diese werden in ihrer Häufigkeit in Prozent an allen auftretenden Abstände in dem Plot eingetragen.
                             Verwendet wurden dafür nur die Testdaten. Links für das Bruteforce Szenario und rechts für das CVE-2019-5418 Szenario.
                             Blau: Nur Normalverhalten, Rot: Normalverhalten und Angriffsverhalten}
                    \label{fig:time_delta}
                \end{figure}

                Die Umsetzung der beschriebenen Idee wird erreicht indem der zeitlichen Abstand $\tau$ zwischen zwei aufeinanderfolgenden System Calls berechnet wird und diesen als weiteren Eingabeparameter für den verarbeitenden Algorithmus verwendet wird.
                In der Trainingsphase wird zunächst nur der größte Abstand $\tau_{max}$ aus den Trainingsdaten ermittelt.
                Mithilfe dieses Wertes werden dann in der Testphase alle Werte wie in \autoref{eq:time_norm} beschrieben normalisiert.
                \begin{equation}\label{eq:time_norm}
                    \tau_{norm} = \frac{\tau}{\tau_{max}}
                \end{equation}
                So gilt für die meisten Werte $\tau_{norm}=[0;1]$.
                Falls $\tau\geq\tau_{max}$ gilt, kann dieser Wert auch größer als $1$ werden.

                Doch treten mit der Verwendung dieser Information als Extraparameter zwei Probleme auf.

                Zum einen stellt sich die Frage, ob eine Verbesserung von einem Szenario mit abweichenden Abständen eine Verschlechterung in Szenarien in welchen dies nicht der Fall ist zur Folge hat.
                Und zum anderen stellt sich die generelle Frage ob diese Information den möglichen Ergebnisraum wesentlich vergrößert und damit die Suche nach einem globalen Minimum erschwert.
                Denn das Betriebssystem selbst beeinflusst die Timings der System Calls, so könnten Informationen eingebettet werden welche wenig Aussagekraft über das Normalverhalten eines Prozesses haben.
                Ob dies das Lernen des Normalverhaltens verbessert oder verschlechtert wird in \autoref{sec:Ergebnis_timing} untersucht.
                %\begin{figure}
                    %\centering
                    %\includegraphics[width=\textwidth]{images/CVE-2012--Test-data-time_delta.pdf}
                    %\caption{Dargestellt ist der zeitliche Abstand zwischen zwei System Calls aus dem selben Thread.
                             %Diese werden in ihrer Häufigkeit in Prozent an allen auftretenden Abstände in dem Plot eingetragen.
                             %Verwendet wurden dafür nur die Testdaten des 
                             %Blau: Nur Normalverhalten}
                    %\label{fig:time_delta_werte}
                %\end{figure}

            \paragraph{Return Werte}

                Wie in \autoref{sec:related_sys_arg} angemerkt, besteht ein System Calls aus zwei \glqq Phasen\grqq.
                Wobei die zweite Phase den Rückgabewert des Betriebssystemskernel beinhaltet.
                Unter anderem gibt der Rückgabewert an wieviele Bytes durch einen \textit{write} System Call gelesen wurden.
                Speziell soll in dieser Arbeit die Kodierung von System Calls betrachtet werden welche Daten schreiben oder lesen und Daten über Sockets empfangen oder senden. 
                Dabei wurden nur System Calls betrachtet, die auch im Datensatz vorkamen und einen Byte Rückgabewert haben.
                Leider fallen dabei System Calls wie \textit{send} heraus, da der Rückgabewert die Anzahl der gesendeten Charaktere angibt und nicht die Anzahl an geschriebenen Bytes.
                In \autoref{tab:syscall_return} werden diese System Calls mit einer Kurzbeschreibung vorgestellt.

                \begin{table}[ht]
                    \small
                    \centering
                    \begin{tabular}{cp{6cm}p{3cm}}
                        \hline
                        \rowcolor{GruvGray!36}
                        \multicolumn{3}{c}{System Calls}\\
                        \hline
                        Name & Beschreibung & Rückgabewerte\\
                        \hline
                        \hline
                        \rowcolor{GruvGray!16}
                        %open& Öffnet die von \textit{pathname} spezifizierte File. Falls diese nicht existiert kann sie mit dem Zusatz \textit{O_CREAT} automatisch erstellt werden & path, asdklfjs, slddk\\
                        write   & Schreibt bis zu \textit{count} Bytes aus dem Buffer (ab Stelle \textit{buf}) in die Datei, welche über den Filedeskriptor $fd$ definiert wird. & Geschriebene Bytes oder $-1$ bei Fehler\\
                        pwrite  & Schreibt bis zu \textit{count} Bytes aus dem Buffer (ab Stelle \textit{buf}) in die Datei, welche über den Filedeskriptor $fd$ definiert wird. Dabei wird der Datei Offset nicht geändert.& Geschriebene Bytes oder $-1$ bei Fehler\\
                        \rowcolor{GruvGray!16}
                        writev  & Schreibt \textit{iovcnt} Vektor in die Datei, welche über den Filedeskriptor $fd$ definiert wird.& Geschriebene Bytes oder $-1$ bei Fehler\\

                        read    & Versucht bis zu \textit{count} Bytes von Filedeskriptor \textit{fd} zu lesen und passt den Datei Offset an.                                              & Filedeskriptor oder $-1$ bei Fehler\\
                        \rowcolor{GruvGray!16}
                        pread   & Versucht bis zu \textit{count} Bytes von Filedeskriptor \textit{fd} zu lesen und passt den Datei Offset nicht an.                                        & Filedeskriptor oder $-1$ bei Fehler\\
                        readv   & Liest spezifizierten \textit{iovcnt} Vektor aus Filedeskriptor \textit{fd} & Gelesene Bytes oder Fehlerwert $-1$\\

                        \rowcolor{GruvGray!16}

                        \makecell{sendfile, sendmsg} & Sende Nachricht über Socket    & Gesendete Bytes oder $-1$ bei Fehler\\
                        \makecell{recvfrom, recv,\\ recvmsg}& Erhalte Nachricht über Socket     & Empfangene Bytes oder $-1$ bei Fehler\\
                        \hline
                    \end{tabular}
                    \caption{Kurzbeschreibung ausgewählter System Calls.\cite{SYSCALL_MANPAGE}}
                    \label{tab:syscall_return}
                \end{table}

                Für die beschriebenen System Calls werden nun in \autoref{fig:return_values} die normalisierten Byte Rückgabewerte\marginpar{Analog zu den Zeitabständen} dargestellt.                
                Diese werden in ihrer Häufigkeit in Prozent an allen auftretenden Rückgabewertgrößen in dem Plot eingetragen. 
                Beispielhaft wird dafür das CVE-2017-7529 Szenario genutzt.
                Für die System Calls read, pread und readv sind die Rückgabewertgrößen im Normalverhalten wie im Normalverhalten mit zusätzlichem Angriffsverhalten gleich und zwar ca.\ 615 Bytes.
                Bei allen anderen betrachteten Rückgabewerten ist ein Unterschied in den auftretenden Größen bei zusätzlichem Angriffsverhalten zu erkennen.
                So zum Beispiel bei den write, pwrite, und writev System Calls.
                Im Normalverhalten werden entweder 100 oder ca. 250 Bytes geschrieben, im Angriffsverhalten kommen noch weitere sehr selten auftretende Größen vor.
                Wie sich die Verwendung der normalisierten Rückgabewerte spezieller System Calls auf die Ergebnisse auswirkt wird in \autoref{sec:Ergebnis_return} behandelt.

                
                \begin{figure}[ht]
                    \centering
                    \includegraphics[width=\textwidth]{images/return_2017_plot.pdf}
                    \caption{Histogramm der gelesenen/erhaltenen Bytes für die Testdaten des \ac{LID-DS}~\cite{LID-DS} CVE-2017-7529 Szenarios.
                    Dargestellt wird dabei immer der Anteil einer Rückgabewertgröße in Byte an allen Rückgabewertgrößen der besagten System Calls.
                    Links oben für die von den System Calls \textit{write, pwrite} und \textit{writev} geschriebenen Bytes.
                    Rechts oben für die von \textit{read, pread} und \textit{readv} gelesenen Bytes.
                    Links unten für die von \textit{sendfile} und \textit{sendmsg} über Sockets gesendete Bytes.
                    Rechts unten für die von \textit{recvfrom, recv} und \textit{recvmsg} über Sockets erhaltenen Bytes.
                    Blau: Nur Normalverhalten, Rot:Normalverhalten und Angriffsverhalten}
                    \label{fig:return_values}
                \end{figure}

%
        \subsection{Wie wird ein Datenstream dargestellt?}\label{sec:streamdarstellung}
        
            Nachdem die Kodierung eines System Calls inklusive zwei weitere Parameter neben dem Namen selbst besprochen wurde, soll in diesem Abschnitt die Abarbeitung mehrerer System Calls für den verarbeitenden Algorithmus vorbereitet werden.
            Dabei werden die Abfolge der System Calls des Datensatzes als ein kontinuierlicher Stream betrachtet.
            Dies ermöglicht den Einsatz der entwickelten Vorgehensweise in der Praxis auch im Live-Betrieb, sofern die Verarbeitung entsprechend schnell stattfindet.
            Für viele Algorithmen wie zum Beispiel auch neuronale Netze ist es sinnvoll und Teilweise unausweichlich eine feste Eingangsgröße festzulegen.
            Um dies für einen Stream zu ermöglichen werden in der \ac{NLP} schon seit langer Zeit n-gramme verwendet~\cite{NGRAMSUEN1979}.
            Auch in der auf System Call basierten Anomalieerkennung kommen n-gramme zum Einsatz~\cite{STIDE_Alternatives, SYSCALL_GRAPHS, IDSTHREADGRIMMER2021}.
            Ein n-gramm ist eine zusammenhängende Folge von $n$ Elementen aus einer gegebenen Eingabe.
            Diese werden wie in \autoref{fig:ngram} aufgebaut.

            \begin{figure}
                %ngram image
                \caption{Erstellung eines n-grams}
                \label{fig:ngram}
            \end{figure}

            Zu beachten ist dabei, dass die Abfolge der System Calls mehrere Abfolgen zusammenführen.
            Denn moderne Computer Systeme können mehrere Threads quasi parallel verarbeiten.
            Die System Calls aller Threads werden dann je nach dem wie sie vom Betriebssystemskernel verarbeitet werden in die Sequenz eingeführt.
            
            \paragraph{Thread Awareness}
                Grimmer et al.~\cite{IDSTHREADGRIMMER2021} beschreiben in ihrer Arbeit wie sie die Thread Information der System Calls verwendet um die verwundenen Sequenzen zu entzerren.
                Dabei werden nur dann System Calls einem n-gram hinzugefügt, sofern die zuvor hinzugefügten System Calls aus dem selben Thread stammen.
                Wie sich diese n-gramme dann aufbauen wird in~\autoref{fig:ngram_thread} dargelegt.

                \begin{figure}
                    %thread ngram image
                    \caption{Erstellung eines n-grams}
                    \label{fig:ngram_thread}
                \end{figure}

                %und speziell von welchen System Calls diese Argumente kommen.spannend
                %Auch wenn ein allgemeiner Ansatz zur Kodierung wichtiger 
                %most frequent calls
                %Sql: vfrom, fcntl, lstat, nmap, poll
                %php: vfrom, fcntl, lstat, nmap, poll
                %bru: writev,read,  close, nmap, poll
                %eps: open,  read,  fstat, mmap, brk
                %zip: futex, write, getpid,protect,open
                %2019: statat,write, futex, stat, getpid
                %2014: writev,read,  nmap,  close,poll
                %2017: lwait,close,ollctl,write,writev
                %2018: statat,write, futex, getpid, stat


                %unique:
                    %vfrom, fcntl, lstat, nmap, poll, writev, read, close, open, fstat, mmap, brk
                    %futex, write, getpid, protect, statat, stat, lwait, ollctl

            %\begin{table}[ht]
                %\small
                %\label{tab:syscall}
                %\centering
                %\begin{tabular}{c||p{6cm}|p{3cm}|p{3cm}}
                    %\hline
                    %\rowcolor{Gray!36}
                    %\multicolumn{3}{c}{System Calls}\\
                    %\hline
                    %Name & Beschreibung & Interessante Argumente & return\\
                    %\hline
                    %\hline
                    %\rowcolor{Gray!16}
                    %fcntl & manipulate current fd & None & None
                    %\hline
                    %lstat & file status & path & 
                    %\rowcolor{Gray!16}
                    %mmap & map or unmap files or devices into memory & addr, length, fd,... & pointer to maped area
                    %poll & wait for event on fd & fds (fd, events, revents), timeout
                    %\rowcolor{Gray!16}
                    %open& Öffnet die in \textit{path} spezifizierte File und gibt einen \textit{file descriptor} zurück.& \textit{path}, \textit{flags}, \textit{mode} \\
                    %write& Schreibt bis zu \textit{count} Bytes aus dem Buffer (ab Stelle \textit{buf}) in die File, welche über den \textit{file descriptor}$fd$ definiert wird. & $fd$, $*buf$, \textit{count} \\
                    %\hline
                %\end{tabular}
                %\caption{Beschreibung ausgewählter System Calls}
            %\end{table}

                %Anzahl unique return Werte, nur numerische Werte betrachtet, 
                %res=-11(<f>/path/to/some/file) wird als -11 interpretiert
                %Bruteforce: 17192 2851 int, 14333 hex, 8 else
                %2012:       1897 193 int, 1698 hex, 6
                %2014:       16736 2706, 14022, 8
                %2017:       381 26, 354, 1 
                %2018:       110 106, 0, 4 
                %2019:       125 119 int werte und 6 else
                %SQL
                %EPS
                %PHP
                %Zipslip
%
                %Hinweis 3 Kategorien evtl kategorische Einteilung bei geringer Anzahl
                %Mögliche Bedeutungen bei else:
                    %Meist Fehlermeldungen!!!
                    %stat:
                        %file status, 
                        %sollte 0 bei success und -1 bei error, gefunden auch -2 
                    %ioctl:
                        %manipulate underlying device, 
                        %normalerweise 0 bei success manchmal negative werte
                        %-1 bei error
                        %manchmal return als ausgabe parameter
                    %Kategorische Betrachtung sinnvoll
                %HEX:\@
                    %mmap:
                        %map or unmap files into memory
                        %return pointer to mapped area
                    %brk:
                        %change data segment size
                        %return 0 on success -1 on error
                        %got hex value

                %Systemcalls welche Rückgabewerte haben:
                    %Bruteforce: {
                                 %'writev': 126627,
                                 %'read': 92587,
                                 %'munmap': 90757,
                                 %'close': 80535,
                                 %'poll': 64443,
                                 %'mmap': 45437,
                                 %'write': 39703,
                                 %'fcntl': 35722,
                                 %'brk': 30372,
                                 %'stat': 28356,
                                 %'semop': 27435,
                                 %'epoll_wait': 13746,
                                 %'fstat': 12950,
                                 %'shutdown': 11127,
                                 %'select': 11012, 
                                 %'lstat': 8060,
                                 %'getcwd': 4616,
                                 %'chdir': 4616,
                                 %'rename': 2308,
                                 %'connect': 4106,
                                 %'lseek': 1410                           ,
                                 %'clone': 1409,
                                 %'setgid': 705,
                                 %'setuid': 705}
                                 %'getdents': 40,

                    %2012: {
                            % 'read': 209140,
                            % 'futex': 149729,
                            % 'setsockopt': 148874,
                            % 'fcntl': 147382,
                            % 'write': 71308,
                            % 'pwrite': 25132,
                            % 'select': 7846,
                            % 'access': 3337,
                            % 'clone': 2523,
                            % 'mmap': 1723,
                            % 'poll': 1262,
                            % 'stat': 960,
                            % 'shutdown': 959,
                            % 'close': 959}
                            % 'munmap': 464,

                    %2014: {
                            % 'writev': 122406,
                            % 'munmap': 90471,
                            % 'read': 90368,
                            % 'close': 79167,
                            % 'poll': 62797,
                            % 'mmap': 44653,
                            % 'write': 38219,
                            % 'fcntl': 35692,
                            % 'brk': 28193,
                            % 'semop': 27166,
                            % 'stat': 26827,
                            % 'epoll_wait': 13629,
                            % 'fstat': 12290,
                            % 'shutdown': 11112,
                            % 'select': 11094,
                            % 'lstat': 7826,
                            % 'getcwd': 4324,
                            % 'chdir': 4324,
                            % 'connect': 4231,
                            % 'rename': 2162,
                            % 'clone': 1480,
                            % 'lseek': 1480,
                            % 'setgid': 740,
                            % 'setuid': 740,
                            % 'getdents': 34} 

                    %2017: {'epoll_wait': 53355,
                            % 'close': 52823,
                            % 'fstat': 26385,
                            % 'writev': 26110,
                            % 'sendfile': 26110,
                            % 'pread': 26109,
                            % 'write': 26109,
                            % 'recvfrom': 26108,
                            % 'getdents': 552,
                            % 'brk': 368,
                            % 'recvmsg': 330} 
                            % 'stat': 276,
                            % 'sendmsg': 166,
                            % 'futex': 92,

                    %2018: {
                            % 'write': 576100,
                            % 'futex': 262846,
                            % 'stat': 252081,
                            % 'read': 119433,
                            % 'close': 82304,
                            % 'fstat': 82226,
                            % 'select': 56420,
                            % 'setsockopt': 54836,
                            % 'ioctl': 54824,
                            % 'lseek': 54824,
                            % 'getsockopt': 27405,
                            % 'recvfrom': 27403,
                            % 'fcntl': 27396,
                            % 'poll': 4654,
                            % 'lstat': 3,
                            % 'pread': 3} 

                    %2019: {
                            % 'write': 542742,
                            % 'futex': 359158,
                            % 'stat': 307293,
                            % 'read': 136356,
                            % 'fstat': 81543,
                            % 'close': 81599,
                            % 'select': 75772,
                            % 'ioctl': 54282,
                            % 'setsockopt': 54269,
                            % 'lseek': 54250,
                            % 'fcntl': 27245,
                            % 'recvfrom': 27145,
                            % 'getsockopt': 27129,
                            % 'poll': 9050,
                            % 'lstat': 245,
                            % 'rename': 32,
                            % 'getdents': 32}
                            % 'unlink': 21,
                            % 'pread': 21,

                %ohe und w2v
                %word embedding parameterwahl wichtig $sqrt(distinct)$
                %Threadid kodieren: 
                %\begin{itemize}
                    %\item use entity embedding for ThreadID~\cite{GUO2016} 
                    %\item relationship between threads and reduce size (possible 1000 different threads)
                    %\item choose size of embedding -thumbrule $sqrt(unique value)$
                %\end{itemize}
                %zeit kodieren
                %\begin{itemize}
                    %\item use time delta of two different syscalls as new input
                %\end{itemize}
                %parameterlänge kodieren
                %\begin{itemize}
                    %\item syscall to int: Wandle Syscall name in Integer um
%
                     %ohe of sysint: use ohe for every syscall 
                     %n * (distinct calls + 1) eingabeneuronen 

                     %w2v von syscall
                     %weniger neuronen und nähe von syscall!!!
                    %\item ngram bilden: Bilde entsprechend angegebenes n ngramm
                %\end{itemize}
                %overhead berechnung embedding, muss allerdings nur einmal berechnet werden
                %zu erkennen w2v mit embedding size = 2  und window = 4 wesentlich schneller
                %embedding größer -> langsamer
                %vergleich ngram
                %im schnitt mit ngram gr 2 84\% von ngr 3 und 
                %w2v bringt entscheidenden Vorteil gegenüber ohe:
                %Jeweils vergleich der selben parameter außer w2v vs ohe:
                %Single small w2v nur 30\% der zeit gegenüber single small ohe
                %bei mulit w2v sogar nur 13\%
                %im mittel über alle architekturen 21.5\% der Zeit von ohe bei verwendung w2v

                %Anzahl unique return Werte, nur numerische Werte betrachtet, 
                %res=-11(<f>/path/to/some/file) wird als -11 interpretiert
                %Bruteforce: 17192 2851 int, 14333 hex, 8 else
                %2012:       1897 193 int, 1698 hex, 6
                %2014:       16736 2706, 14022, 8
                %2017:       381 26, 354, 1 
                %2018:       110 106, 0, 4 
                %2019:       125 119 int werte und 6 else
                %SQL
                %EPS
                %PHP
                %Zipslip
%
                %Hinweis 3 Kategorien evtl kategorische Einteilung bei geringer Anzahl
                %Mögliche Bedeutungen bei else:
                    %Meist Fehlermeldungen!!!
                    %stat:
                        %file status, 
                        %sollte 0 bei success und -1 bei error, gefunden auch -2 
                    %ioctl:
                        %manipulate underlying device, 
                        %normalerweise 0 bei success manchmal negative werte
                        %-1 bei error
                        %manchmal return als ausgabe parameter
                    %Kategorische Betrachtung sinnvoll
                %HEX:\@
                    %mmap:
                        %map or unmap files into memory
                        %return pointer to mapped area
                    %brk:
                        %change data segment size
                        %return 0 on success -1 on error
                        %got hex value

                %Systemcalls welche Rückgabewerte haben:
                    %Bruteforce: {
                                 %'writev': 126627,
                                 %'read': 92587,
                                 %'munmap': 90757,
                                 %'close': 80535,
                                 %'poll': 64443,
                                 %'mmap': 45437,
                                 %'write': 39703,
                                 %'fcntl': 35722,
                                 %'brk': 30372,
                                 %'stat': 28356,
                                 %'semop': 27435,
                                 %'epoll_wait': 13746,
                                 %'fstat': 12950,
                                 %'shutdown': 11127,
                                 %'select': 11012, 
                                 %'lstat': 8060,
                                 %'getcwd': 4616,
                                 %'chdir': 4616,
                                 %'rename': 2308,
                                 %'connect': 4106,
                                 %'lseek': 1410                           ,
                                 %'clone': 1409,
                                 %'setgid': 705,
                                 %'setuid': 705}
                                 %'getdents': 40,

                    %2012: {
                            % 'read': 209140,
                            % 'futex': 149729,
                            % 'setsockopt': 148874,
                            % 'fcntl': 147382,
                            % 'write': 71308,
                            % 'pwrite': 25132,
                            % 'select': 7846,
                            % 'access': 3337,
                            % 'clone': 2523,
                            % 'mmap': 1723,
                            % 'poll': 1262,
                            % 'stat': 960,
                            % 'shutdown': 959,
                            % 'close': 959}
                            % 'munmap': 464,

                    %2014: {
                            % 'writev': 122406,
                            % 'munmap': 90471,
                            % 'read': 90368,
                            % 'close': 79167,
                            % 'poll': 62797,
                            % 'mmap': 44653,
                            % 'write': 38219,
                            % 'fcntl': 35692,
                            % 'brk': 28193,
                            % 'semop': 27166,
                            % 'stat': 26827,
                            % 'epoll_wait': 13629,
                            % 'fstat': 12290,
                            % 'shutdown': 11112,
                            % 'select': 11094,
                            % 'lstat': 7826,
                            % 'getcwd': 4324,
                            % 'chdir': 4324,
                            % 'connect': 4231,
                            % 'rename': 2162,
                            % 'clone': 1480,
                            % 'lseek': 1480,
                            % 'setgid': 740,
                            % 'setuid': 740,
                            % 'getdents': 34} 

                    %2017: {'epoll_wait': 53355,
                            % 'close': 52823,
                            % 'fstat': 26385,
                            % 'writev': 26110,
                            % 'sendfile': 26110,
                            % 'pread': 26109,
                            % 'write': 26109,
                            % 'recvfrom': 26108,
                            % 'getdents': 552,
                            % 'brk': 368,
                            % 'recvmsg': 330} 
                            % 'stat': 276,
                            % 'sendmsg': 166,
                            % 'futex': 92,

                    %2018: {
                            % 'write': 576100,
                            % 'futex': 262846,
                            % 'stat': 252081,
                            % 'read': 119433,
                            % 'close': 82304,
                            % 'fstat': 82226,
                            % 'select': 56420,
                            % 'setsockopt': 54836,
                            % 'ioctl': 54824,
                            % 'lseek': 54824,
                            % 'getsockopt': 27405,
                            % 'recvfrom': 27403,
                            % 'fcntl': 27396,
                            % 'poll': 4654,
                            % 'lstat': 3,
                            % 'pread': 3} 

                    %2019: {
                            % 'write': 542742,
                            % 'futex': 359158,
                            % 'stat': 307293,
                            % 'read': 136356,
                            % 'fstat': 81543,
                            % 'close': 81599,
                            % 'select': 75772,
                            % 'ioctl': 54282,
                            % 'setsockopt': 54269,
                            % 'lseek': 54250,
                            % 'fcntl': 27245,
                            % 'recvfrom': 27145,
                            % 'getsockopt': 27129,
                            % 'poll': 9050,
                            % 'lstat': 245,
                            % 'rename': 32,
                            % 'getdents': 32}
                            % 'unlink': 21,
                            % 'pread': 21,

                %ohe und w2v
                %word embedding parameterwahl wichtig $sqrt(distinct)$
                %Threadid kodieren: 
                %\begin{itemize}
                    %\item use entity embedding for ThreadID~\cite{GUO2016} 
                    %\item relationship between threads and reduce size (possible 1000 different threads)
                    %\item choose size of embedding -thumbrule $sqrt(unique value)$
                %\end{itemize}
                %zeit kodieren
                %\begin{itemize}
                    %\item use time delta of two different syscalls as new input
                %\end{itemize}
                %parameterlänge kodieren
                %\begin{itemize}
                    %\item syscall to int: Wandle Syscall name in Integer um
%
                     %ohe of sysint: use ohe for every syscall 
                     %n * (distinct calls + 1) eingabeneuronen 

                     %w2v von syscall
                     %weniger neuronen und nähe von syscall!!!
                    %\item ngram bilden: Bilde entsprechend angegebenes n ngramm
                %\end{itemize}
                %overhead berechnung embedding, muss allerdings nur einmal berechnet werden
                %zu erkennen w2v mit embedding size = 2  und window = 4 wesentlich schneller
                %embedding größer -> langsamer
                %vergleich ngram
                %im schnitt mit ngram gr 2 84\% von ngr 3 und 
                %w2v bringt entscheidenden Vorteil gegenüber ohe:
                %Jeweils vergleich der selben parameter außer w2v vs ohe:
                %Single small w2v nur 30\% der zeit gegenüber single small ohe
                %bei mulit w2v sogar nur 13\%
                %im mittel über alle architekturen 21.5\% der Zeit von ohe bei verwendung w2v
                Thread information erweitern
                    Grimmer ngramme thread aware sinnvoll bei multithread anwendungen 
                    bei ihren verwendeted algorithmen ausreichend
                    für LSTM kontext wichtig, deshalb angeben ob aktueller thread aus selben Kontext wie der vorige kommt

                %Anzahl unique return Werte, nur numerische Werte betrachtet, 
                %res=-11(<f>/path/to/some/file) wird als -11 interpretiert
                %Bruteforce: 17192 2851 int, 14333 hex, 8 else
                %2012:       1897 193 int, 1698 hex, 6
                %2014:       16736 2706, 14022, 8
                %2017:       381 26, 354, 1 
                %2018:       110 106, 0, 4 
                %2019:       125 119 int werte und 6 else
                %SQL
                %EPS
                %PHP
                %Zipslip
%
                %Hinweis 3 Kategorien evtl kategorische Einteilung bei geringer Anzahl
                %Mögliche Bedeutungen bei else:
                    %Meist Fehlermeldungen!!!
                    %stat:
                        %file status, 
                        %sollte 0 bei success und -1 bei error, gefunden auch -2 
                    %ioctl:
                        %manipulate underlying device, 
                        %normalerweise 0 bei success manchmal negative werte
                        %-1 bei error
                        %manchmal return als ausgabe parameter
                    %Kategorische Betrachtung sinnvoll
                %HEX:\@
                    %mmap:
                        %map or unmap files into memory
                        %return pointer to mapped area
                    %brk:
                        %change data segment size
                        %return 0 on success -1 on error
                        %got hex value

                %Systemcalls welche Rückgabewerte haben:
                    %Bruteforce: {
                                 %'writev': 126627,
                                 %'read': 92587,
                                 %'munmap': 90757,
                                 %'close': 80535,
                                 %'poll': 64443,
                                 %'mmap': 45437,
                                 %'write': 39703,
                                 %'fcntl': 35722,
                                 %'brk': 30372,
                                 %'stat': 28356,
                                 %'semop': 27435,
                                 %'epoll_wait': 13746,
                                 %'fstat': 12950,
                                 %'shutdown': 11127,
                                 %'select': 11012, 
                                 %'lstat': 8060,
                                 %'getcwd': 4616,
                                 %'chdir': 4616,
                                 %'rename': 2308,
                                 %'connect': 4106,
                                 %'lseek': 1410                           ,
                                 %'clone': 1409,
                                 %'setgid': 705,
                                 %'setuid': 705}
                                 %'getdents': 40,

                    %2012: {
                            % 'read': 209140,
                            % 'futex': 149729,
                            % 'setsockopt': 148874,
                            % 'fcntl': 147382,
                            % 'write': 71308,
                            % 'pwrite': 25132,
                            % 'select': 7846,
                            % 'access': 3337,
                            % 'clone': 2523,
                            % 'mmap': 1723,
                            % 'poll': 1262,
                            % 'stat': 960,
                            % 'shutdown': 959,
                            % 'close': 959}
                            % 'munmap': 464,

                    %2014: {
                            % 'writev': 122406,
                            % 'munmap': 90471,
                            % 'read': 90368,
                            % 'close': 79167,
                            % 'poll': 62797,
                            % 'mmap': 44653,
                            % 'write': 38219,
                            % 'fcntl': 35692,
                            % 'brk': 28193,
                            % 'semop': 27166,
                            % 'stat': 26827,
                            % 'epoll_wait': 13629,
                            % 'fstat': 12290,
                            % 'shutdown': 11112,
                            % 'select': 11094,
                            % 'lstat': 7826,
                            % 'getcwd': 4324,
                            % 'chdir': 4324,
                            % 'connect': 4231,
                            % 'rename': 2162,
                            % 'clone': 1480,
                            % 'lseek': 1480,
                            % 'setgid': 740,
                            % 'setuid': 740,
                            % 'getdents': 34} 

                    %2017: {'epoll_wait': 53355,
                            % 'close': 52823,
                            % 'fstat': 26385,
                            % 'writev': 26110,
                            % 'sendfile': 26110,
                            % 'pread': 26109,
                            % 'write': 26109,
                            % 'recvfrom': 26108,
                            % 'getdents': 552,
                            % 'brk': 368,
                            % 'recvmsg': 330} 
                            % 'stat': 276,
                            % 'sendmsg': 166,
                            % 'futex': 92,

                    %2018: {
                            % 'write': 576100,
                            % 'futex': 262846,
                            % 'stat': 252081,
                            % 'read': 119433,
                            % 'close': 82304,
                            % 'fstat': 82226,
                            % 'select': 56420,
                            % 'setsockopt': 54836,
                            % 'ioctl': 54824,
                            % 'lseek': 54824,
                            % 'getsockopt': 27405,
                            % 'recvfrom': 27403,
                            % 'fcntl': 27396,
                            % 'poll': 4654,
                            % 'lstat': 3,
                            % 'pread': 3} 

                    %2019: {
                            % 'write': 542742,
                            % 'futex': 359158,
                            % 'stat': 307293,
                            % 'read': 136356,
                            % 'fstat': 81543,
                            % 'close': 81599,
                            % 'select': 75772,
                            % 'ioctl': 54282,
                            % 'setsockopt': 54269,
                            % 'lseek': 54250,
                            % 'fcntl': 27245,
                            % 'recvfrom': 27145,
                            % 'getsockopt': 27129,
                            % 'poll': 9050,
                            % 'lstat': 245,
                            % 'rename': 32,
                            % 'getdents': 32}
                            % 'unlink': 21,
                            % 'pread': 21,

                %ohe und w2v
                %word embedding parameterwahl wichtig $sqrt(distinct)$
                %Threadid kodieren: 
                %\begin{itemize}
                    %\item use entity embedding for ThreadID~\cite{GUO2016} 
                    %\item relationship between threads and reduce size (possible 1000 different threads)
                    %\item choose size of embedding -thumbrule $sqrt(unique value)$
                %\end{itemize}
                %zeit kodieren
                %\begin{itemize}
                    %\item use time delta of two different syscalls as new input
                %\end{itemize}
                %parameterlänge kodieren
                %\begin{itemize}
                    %\item syscall to int: Wandle Syscall name in Integer um
%
                     %ohe of sysint: use ohe for every syscall 
                     %n * (distinct calls + 1) eingabeneuronen 

                     %w2v von syscall
                     %weniger neuronen und nähe von syscall!!!
                    %\item ngram bilden: Bilde entsprechend angegebenes n ngramm
                %\end{itemize}
                %overhead berechnung embedding, muss allerdings nur einmal berechnet werden
                %zu erkennen w2v mit embedding size = 2  und window = 4 wesentlich schneller
                %embedding größer -> langsamer
                %vergleich ngram
                %im schnitt mit ngram gr 2 84\% von ngr 3 und 
                %w2v bringt entscheidenden Vorteil gegenüber ohe:
                %Jeweils vergleich der selben parameter außer w2v vs ohe:
                %Single small w2v nur 30\% der zeit gegenüber single small ohe
                %bei mulit w2v sogar nur 13\%
                %im mittel über alle architekturen 21.5\% der Zeit von ohe bei verwendung w2v

    \section{Algorithmus}\label{sec:Algorithmus}
        \ac{LSTM} Sprachmodell soll Wahrscheinlichkeit des nächsten System Calls vorhersagen, gegeben eines System Calls oder einer Sequenz von System Calls.
        Gab es in den Trainingsdaten die feste Menge $S = {1,\dots,N}$ an System Calls, so gibt $x=x_1\dots x_l \ (x_i\in S)$ die Sequenz an $l$ System Calls an.
        Jeder dieser System Calls bekommt im ersten Schritt einen Integerwert zwischen 1 und $N$.
        Taucht in den Testdaten nun ein noch nicht bekannter System Call $x_i$ auf, also $x_i \notin S$, so erhält dieser den vorläufigen Wert 0.
        Zu jedem Zeitpunkt wird $x_i$ der Input Layer übergeben.
        Dabei wird ein Embedding aus Abschnitt~\ref{sec:embedding} verwendet. 
        Mit den gegebenen Trainingsdaten kann nun das \ac{LSTM} mittels des \textit{back-propagation through time} (BPTT) trainiert werden.
        % Im ersten Schritt besteht dieses Embedding aus dem \textit{One hot encoding} (OHE).
        % In weiterer Ausführung werden dann zwei W2V Verfahren verwendet.
        % Wie in Kapitel \ref{Grundlagen:LSTM} bereits beschrieben wird, soll das LSTM mit den kodierten system calls aus dem Trainingsdatensatz trainiert werden.
        An der Ausgangs Layer befindet sich eine Softmax Aktivierungsfunktion.
        Diese wird verwendet um die Ausgabe zu normalisieren und damit die Wahrscheinlichkeitsverteilung des nächsten System Calls zu erhalten.
        Also $P\left(x_i|x_{1:i-1}\right)$ für alle $i$. 
        

        \subsection{Training}\label{sec:Training}
            Nächsten Syscall vorhersagen und überprüfen ob richtig vorhergesagt
        \subsection{Anomalieerkennung}\label{sec:Anomalieerkennung}
            Es kann also bei Auftreten des System Calls $x_i$ überprüft werden mit welcher Wahrscheinlichkeit $p$ dieser vorhergesagt wurde.
            Der eigentliche Anomalie-Score wird dann folgenderweise berechnet:
            \begin{equation}
                ascore = 1 - p
            \end{equation}
            Unterschreitet dieser einen Schwellwert so wird dies als eine Anomalie gewertet und ein Alarm angezeigt.
        \subsection{Schwellwertbestimmung}
            Um den zuvor erwähnten Schwellwert automatisch zu bestimmen, wird der Algorithmus auf die Validierungsdaten angewendet. 
            Dabei dient der höchste Wert dieser Daten dann als Schwellwert, da angenommen wird, dass mindestens alle Daten aus den Validierungsdaten harmlos sind und damit unter dem Schwellwert liegen sollten.
            Wichtig ist dabei dafür nicht die Trainingsdaten zu wählen, da eine starke Verzerrung der Schwellwertes durch Overfitting der Daten entstehen kann. 
            Das würde bedeuten, dass nur sehr geringe Anomaliewerte auftreten und der Schwellwert sehr gering ist und damit die Gefahr für viele Fehlalarme besteht.

            Alternativ betrachte die x wahrscheinlichsten vorhergesagten system calls, falls tatsächlicher system call nicht dabei --> alarm
            x ermitteln, betrachte validierungsdaten und schaue ob schlechtestes x aussehen würde
            tatsächlich oft einmal schlechteste platzierung und automatische erkennung von x schwer.

            {\color{red} In Datensatzkapitel!}
            \paragraph{Problem des Datensatz}

                In den Testdaten sind \textit{malicious} \marginpar{zu dt.\ schädlich} Files beinhaltet, welche eine Information über den Angriffszeitpunkt liefert. 
                Jedoch gibt es bei einer malicious File im Gegensatz zu den normalen Files  vier mögliche Zuordnungen.
                %TODO Bild einfügen von Quadranten 
                Befindet sich der Anomaliescore unter dem Schwellwert kann von einem \textit{True Negative} eingestuft werden.
                Also es wurde korrekter weise kein Alarm vorhergesagt.
                Befindet sich der Anomaliescore vor dem Angriffszeitpunkt über dem Schwellwert liegt ein \textit{False Positive} vor.
                Es wurde ein Alarm gemeldet an einer Stelle an dem kein Angriff stattfand.
                Nach dem angegebenen Angriffszeitpunkt wird es allerdings schwieriger.
                Denn liegt der Anomaliescore nach dem Angriffszeitpunkt über dem Schwellwert, wird von einem \textit{True Positive}, also einem korrektem Alarm ausgegangen.
                Jedoch kann da der Angriff schon vorbei sein, oder gar noch nicht gestartet sein.
                Es können nach dem Angriffszeitpunkt auch \textit{False Positive} oder \textit{False Negative} geben, welche allerdings nicht als solche erkannt werden können.
                Wie sich das auf die Auswertung der Ergebnisse auswirkt wird in Kapitel~\ref{sec:Metriken} beleuchtet.

        \subsection{Parameterwahl}
            ngram länge
            lstm merkt sich vorherige syscalls aber hinzunahme von syscalls weitere info
            -> finden von sweet spot
            generell großes n viele alarme
            kleines n weniger alarme  vorteil \ac{LSTM}\@?
            wichtiger Parameter den es zu ermitteln gilt

    \section{Strukturierung der Experimente}\label{sec:StrukExp}
        Um aussagekräftige Experimente zu entwickeln müssen zuerst 
        überlegungen zur praktischen umsetzung gemacht werden
        dabei wird in ersten Tests klar, dass zeit hierbei eine große rolle spielen wird

        erste Tests also ausgelegt um Faktoren zu ermitteln, welche die auswertungen stark verlangsamen
        und diese ausschließen.

        \subsection{Faktor Zeit}

            zeit/dr als groesse und farbe von scatter plot
            batch size test und train x/y achse

            eingrenzen von moeglichen konfigurationen

            Berechnungszeiten aus verschiedenen Perspektiven relevant:
            soll live system werden
            begrenzte rechenleistung und viele Tests zur auswertung von parametern architektur etc
            erster test zur abschätzung diverser zeitl.\ faktoren:

            Faktoren:
            \begin{itemize}
                \item Architektur
                \item Verarbeitung Stream

                     ngram größe
                \item embedding
            \end{itemize}
        ngram größe, architektur und verwendung w2v statt ohe
        Grobe Abschätzung der Zeit, da Berechnungen auf Clustern ausgeführt werden von Auslastung beeinflusst werden.
        Klare Erkenntnisse:

            Single Small 50 neuronen eine schicht:
            Single Big 250 neuronen eine schicht
            multi 50 neuronrn 3 schichten

        erste Abschätzung von Nutzen von Thread 
        einführen von stateful sowie Batch Normalization

    \subsection{Optimale Parameter}

        \paragraph{Architektur}
            versch architekturen:
            Single Small 50 neuronen eine schicht
            Single Big 250 neuronen eine schicht
            multi small 20 neuronen 3 schichten
            multi big 50 neuronrn 3 schichten
            deep erste 50 sonst 20 6 schichten

            singlesmall 43\% von Deep
            insgesamt am schnellsten single small
            wie zu erwarten,  deep am langsamsten

            teste eine schicht viele neuronen 
            eine schicht wenige neuronen
            mehrere schichten mehrere neuronen / mit dropout dazwischen
            viele schichten wenige neuronen /mit dropout dazwischen

            auf Grund des zeitlichen Faktors fallen Deep und multibig weg
            Also zu testen:
            Single Small
            Single 
            Multi Small
            Multi 

        \paragraph{Hyperparameter}
            aktivierungs funktion
            -> dense layer with softmax or tanh
            batch size
            learning rate
            optimizer

        \paragraph{Ngram Größe}
            ngram größer -> langsamer

        \paragraph{Threadinfo}
            Hypothese:
            Threadinfos bringen was

            Einbinden von thread information auf verschiedenen wegen:
            Thread aware ngrams (tan)
            Thread aware ngrams for w2v (tanw2v)
            Thread change flag (tcf)

            varianten:
            tan
            tanw2v
            tcf
            tan tcf
            tan tanw2v
            tcf tanw2v
            tan tanw2v tcf

            ---> welcher dieser varianten am besten?

        \paragraph{Parameter}
            args
            time

            \ac{LSTM} ohne Threadinfos mit OHE
            LSTM mit W2V ohne Threadinfos (ngram)
            LSTM mit W2V mit Threadinfos (ngram)
            LSTM mit W2V threadaware mit Threadinfos (ngram)
            LSTM mit W2V threadaware mit Threadinfos (ngram) und threadchangeflag
            LSTM mit W2Vthreadaware mit Threadinfos (ngram) und threadchangeflag, spezialtraining
            --> LSTM final

            Manche angriffe verändern Sequenz von syscalls nicht
            Hypothese:
            verwende Parameter um erg zu verb

            LSTM final + strlen
            LSTM final + time delta
            LSTM final + strlen + time delta



\section{Metriken}\label{sec:Metriken}

    Auf Grund dessen Metrik False Alarm/ consecutive false alarm und Detection rate falls einmal pro malicious file in quadrant 4 -> HIT
    Wahl von Metriken in NN
    Precision, Recall, f-score, TNR, FNR, FPR

    problematisch:
    nicht auf systemcall genau gelabelt
    recall precision usw nur auf file ebene:
    alarm nach exploitstarttime wird immer als hit gewertet -> aber evtl angriff noch nicht begonnen
    oder angriff bereits vorbei
    ebenso umgekehrt, eig muss jeder nicht alarm nach exploitstart als FN gewertet werden
    weswegen filegenau geschaut wird
    vorteil des Datensatzes gegenüber anderen, immerhin exploitstart time

    ilarm in quadrant ---> image
