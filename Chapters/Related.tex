%*****************************************
\chapter{Verwandte Arbeiten}\label{ch:verwandte_arbeiten}
%*****************************************

Die Forschungsfrage mit der sich diese Arbeit beschäftigt kann wie in~\autoref{sec:Forschungsfrage} beschrieben kann weiter unterteilt werden.
Zum einen soll untersucht werden inwiefern \ac{LSTM} neuronale Netze in anomaliebasierten \ac{HIDS} Vorteile bringen können.
Und zum anderen wie durch die Anreicherung der Sequenzen von System Calls, durch weitere Informationen neben dem Namen des System Calls, die \ac{FP}-Rate verbessert werden kann.
Um den Überblick über die verwandten Arbeiten nicht zu verlieren sind diese im Folgenden untergliedert.
Zunächst sollen Grundlagen der Anomalieerkennung und erste Ansätze der Anomalieerkennung mit System Calls aufgeführt werden, auf welchen diese Arbeit indirekt fußt.
Im nächsten Schritt werden dann Arbeiten betrachtet, welche speziell die System Call Sequenzen anreichern.
Abschließend werden Arbeiten untersucht welche sich speziell mit dem Einsatz von \ac{RNN} und \ac{LSTM} Netzwerken auseinandersetzen.

\section{Anomaliedetektion}

    Anomaliedetektion wird in vielen Bereichen eingesetzt.
    % Dazu gehören die Erkennung von Betrug, unter anderem bei Kreditkarten~\cite{CREDITBOLTON2001}, das Aufdecken von Unregelmäßigkeiten in medizinischen und Gesundheitsdaten~\cite{MEDIZINHORN2001} oder Schadenserkennung in der Industrie~\cite{INDUSTRIEBASU2007}.
    Die Anfänge der Anomalieerkennug wird von~\cite{ANOMALYBOOKKISHAN2017} auf die Arbeit von~\cite{ANOMALYDEFINITION1969} zurückgeführt, in welcher sogenannte Ausreißer in Sample-Daten gefunden und entfernt werden sollen.
    Hingegen berufen sich~\cite{ANOMALYSURVEY} bei den Anfängen der Anomalieerkennung auf eine Arbeit aus dem~\textit{Dublin Philosophical Magazine of Journal and Science} von 1887~\cite{ANOMALYDEFINITION1887}.
    Dort werden \textit{discordant observations}\marginpar{zu dt.\ nicht stimmige Beobachtung} anhand einer abweichenden gesetzmäßigen Frequenz isoliert. 
    Speziell im Kontext der Angriffserkennung wird wie in~\autoref{sec:Datenerfassung} beschrieben die Anomalieerkennung in \ac{NIDS} und \ac{HIDS} eingeteilt.
    Da es wie in der Anomalieerkennung in diesen Bereichen eine große Anzahl an Arbeiten und auch Übersichtsarbeiten gibt~\cite{ANOMALYSURVEY, ANOMALYSURVEY3}, soll im Folgenden nur auf bestehende Arbeiten im Bereich der \ac{HIDS} eingegangen werden, welche speziell System Calls verwenden.

    \subsection{Anomaliedetektion mit System Calls}

    \paragraph{Sequenzen}
        Bereits 1996 stellten Stephanie Forrest et al.~\cite{FORREST} die erste Arbeit vor in welcher sie mit ihrem \ac{TIDE} Algorithmus Anomalien in System Call Daten ermitteln.
        Dabei wird anhand einer Datenbank gültiger System Call Paare, \textit{lookahead pairs}, ermittelt ob eine System Call Sequenz eine Anomalie darstellt.

        In einer späteren Arbeit erweitern sie diesen Ansatz, indem sie die Datenbank mit zusammenhängende Sequenzen von System Calls befüllen.
        Kommt eine Sequenz nicht in der Datenbank vor wird diese als Anomalie eingestuft, so wird \ac{TIDE} zu \ac{STIDE}.~\cite{STIDE}

        Ein anderen Ansatz wählten 1997 Lee et al.~\cite{LEE1997}, wobei sie sich auch auf die Pionierarbeit von~\cite{FORREST} berufen.
        Sie versuchen mit dem \ac{ML}-Programm \ac{RIPPER} Regeln in den System Call Daten zu lernen~\cite{LEE1997}
        Im Gegensatz zu~\cite{FORREST} werden bei diesem Ansatz normale sowie anormale Sequenzen gelernt.

        1999 untersuchten Warrender et al.\ wie verschiedene Algorithmen auf System Call Daten abschneiden.
        Dazu gehören die bereits erwähnten Verfahren \ac{TIDE}, \ac{STIDE}, \ac{RIPPER}, sowie ein \ac{HMM}.
        Dabei schienen alle Verfahren erfolgreich wobei das \ac{HMM} als sehr rechenintensiv hervorgehoben wird.
        Speziell interessant an dieser Arbeit ist auch die Verwendung von n-grammen aus der Textverarbeitung.~\cite{STIDE_Alternatives}
        Ein n-gramm ist eine zusammenhängende Folge von n Elementen aus einer gegebenen Eingabe.
        Oft wird diese Art der Vorverarbeitung bei Datenstreams eingesetzt.
 
        % Auch in moderneren Arbeiten werden die Abfolge von System Calls beziehungsweise speziell nur die Funktionsnamen verwendet.
        Auch aktuellere Arbeiten befassen sich mit der Anomalieerkennung mit System Calls, {\color{red} speziell nur Namen von System Calls}.
    
        2005 betrachten Kang et al.\ nicht die Sequenzen sondern die Frequenzen der auftretenden System Calls.
        Dabei zählen sie das Vorkommen von System Calls in einem bestimmten Zeitfenster und verwenden diese sogenannten \textit{bag of system calls}\marginpar{zu dt. Bündel von Systemaufrufen} für ihre Beschreibung des Normalverhaltens.
        Ähnlich zu~\cite{FORREST} und~\cite{STIDE} bauen sie mit diesen Bündelungen eine Datenbank für das Normalverhalten auf.~\cite{FREQUENCY2}

        2013 stellen Murtaza et al. System Calls als Zustände von Kernelmodulen dar, indem sie System Calls einem bestimmten Modul zuschreiben.
        Dazu gehört zum Beispiel das Modul \textit{File System} mit den System Calls \textit{read} \textit{write} etc., oder auch \textit{Architecture}, \textit{Memory Management}.
        Der Wahrscheinlichkeiten für das Auftreten von Zustandssequenzen wird dann zur Identifizierung von Anomalien genutzt.~\cite{SYSTEM_STATES}

        2018 interpretieren Grimmer et al. System Call Sequenzen als einen sogenannten \textit{System Call Graph}.
        Dabei werden wie in~\cite{STIDE_Alternatives} n-gramme verwendet.
        Die n-gramme stellen einen Knoten dar und der Übergang eines n-gramms zu einem weiteren wird mit einer gerichteten Kante dargestellt.
        Zusammen mit den Häufigkeiten des Auftretens eines Überganges und dem Ausgangsgrad eines Knotens ergeben sich dann Übergangswahrscheinlichkeiten, für alle Knoten.
        Der Anomaliescore wird dann anhand der Übergangswahrscheinlichkeiten aus dem im Training aufgebauten Graphen abgelesen.~\cite{SYSCALL_GRAPHS} 

        % (2015) Einsatz in Linux Containern~\cite{FREQUENCY1} oder (2018) in Cloud Lösungen~\cite{VM}

    Doch es gibt auch mehrere Arbeiten die Schwachstellen der Angriffserkennung mittels Sequenzen von System Calls aufzeigen.
    % Zumindest sofern nur die Sequenz der System Calls betrachtet wird.
    In~\cite{Syscallseqexploit1} werden verschieden Methoden untersucht mit welchen Angriffe nicht durch das IDS von~\cite{FORREST2000}\marginpar{beruht auf \ac{STIDE}~\cite{STIDE}} erkannt wurden.
    Bei ihren theoretischen Ansätzen berufen sie sich unter anderem auf das Abändern von System Call Argumenten, ohne dabei auf die Sequenz der System Calls einfluss zu nehmen.
    Und~\cite{Syscallseqexploit3} untersuchen speziell die von~\cite{FORREST} ins Spiel gebrachte Fensterlänge von $6$ für den \ac{STIDE} Algorithmus.
    Dabei umgehen sie die Angriffserkennung in dem sie die Angriffssequenzen auseinanderziehen und mit Normalsequenzen auffüllen.

    Dies zeigt, dass es sinnvoll sein kann auch noch weitere Informationen welche in den System Calls enthalten sind einzubinden.
    Seien es Metadaten wie die Thread Information der System Calls, oder auch die eigentlichen Argumente der Aufrufe.
    Inwiefern diese zusätzlichen Informationen bereits in der Literatur verwendet wurde soll nun behandelt werden.

    \paragraph{Mehr als Sequenzen}

        {\color{red}2003 wählen Kruegel et al.\ einen konträren Weg, sie missachten die Sequenz und betrachten nur die Rückgabewerte und Argumente der System Calls.}
        Sie erstellen in der Trainingsphase für jeden System Call verschiedene Modelle, welche in der Testphase die Wahrscheinlichkeit eines anormalen Verhaltens bestimmen.
        Spannend dabei sind mehr die vorgestellten Modelle, als die eigentliche Verarbeitung dieser

        \textit{String Length}: Die Annahme dieses Features besteht darin, dass sich bei einem Angriff die Länge der Strings der Argumente signifikant ändert.
        Dafür wird in der Trainingsphase versucht die Verteilung der String-Längen zu approximieren.S
        In der Testphase wird dann die Wahrscheinlichkeit dafür, dass die aktuelle String-Länge aus der Verteilung stammt mit der \textit{Tschebyschaffschen Ungleichheit} berechnet.
        
        \textit{String Character Distribution}: Hier wird angenommen, dass es unter legitimen System Calls Ähnlichkeiten unter den Frequenzen der auftretenden Zeichen eines Strings gibt.
        In der Trainingsphase wird für jedes gesehene Argument die Zeichenverteilung hinterlegt.
        Ähnlich zu der String-Länge zuvor wird in der Testphase nun überprüft mit welcher Wahrscheinlichkeit die aktuelle Zeichenverteilung aus der gespeicherten Verteilung gezogen wurde.

        \textit{Structural Inference:} Da Angriffe laut Kruegel et al.\ aber auch besonders lange oder auffällige Verteilungen von Argumenten umgehen können, wird versucht auch die Struktur der Argumente zu untersuchen.
        Um diese Struktur zu erlernen, vereinfachen sie die Argumente zunächst wie auch von Maggi et al.~\cite{ARGUMENTS2} beschrieben.
        Beispielhaft wird aus dem Pfad \path{/usr/lib/libc.so} $\longrightarrow$ \path{/a/a/a.a}.
        Für das Erlernen verwenden sie ein Markov Modell.
        Mit Hilfe dieses Modells kann in der Testphase entschieden werden ob die aktuelle Struktur des System Call Arguments durch das Markov Modell erstellt werden kann oder nicht.

        \textit{Token Finder}: Es soll ermittelt werden ob die Werte eines bestimmten System Call Arguments aus einer endlichen Menge von Werten stammt.
        Laut Kruegel et al.\ werden häufig System Calls mit zum Beispiel den selben Flags aufgerufen, allerdings gibt es auch Argumente bei welchen so eine klare Aufteilung unbrauchbar ist.
        Mit einer statistischen Analyse wird deswegen in der Trainingsphase ermittelt ob ein Argument einer zufälligen Verteilung folgt.
        Falls die Anzahl der möglichen Werte nicht proportional mit den Argumenten wächst, werden diese Werte in die Normaldatenbank aufgenommen.
        Wurde ermittelt, dass ein Argument nicht einer Zufallsverteilung folgt, wird in der Testphase überprüft ob der aktuelle Wert in der Normaldatenbank vorkommt oder nicht.

        Um diese Modelle für System Call Argumente einfach nutzbar zu machen wurde von Kruegel et al.\ das LibAnomlay Framework implementiert.~\cite{ARGUMENTS}

        Auch in~\cite{ARGUMENTS2} kommen diese Modelle der Argumente zum Einsatz.
        
        Ebenso werden sie auch von Maggi et al.\ verwendet und mit Hilfe des LibAnomaly Framework bauten sie eine Alternative Verarbeitung dieser Argument-Modelle.~\cite{MAGGI}

        Doch bei allen zuvor erwaehnten Arbeiten mit Verwendung von System Call Argumenten wird die Sequenz der System Calls nicht mehr betrachtet.
        Koucham et al.\ wollen nun im Gegensatz dazu sowohl die Sequenz als auch die Argumente beachten.
        Dafuer Clustern sie durch das Clustern von System Call Argumenten für jeden System Call die betrachteten Sequenzen anreichern.
        ~\cite{ARGUMENTCLUSTERKOUCHAM2015}

        Einen anderen Ansatz wählen Grimmer et al.\ indem sie die vorhandenen Informtionen nicht direkt einbinden, sondern die Thread ID verwenden um die Streamverarbeitung zu verbessern.
        Der Ausgangspunkt ihrer Ueberlegungen liegt darin, dass moderne Prozesse Mulit-Threaded sind.
        Das heisst die Sequenz der System Calls beschreibt die Aktionen mehrere Threads gleichzeitig.
        Um diese Vermischung der Threads zu verhindern bilden sie n-gramme, welche nur aus System Calls desselben Thread stammen.
        So konnten sie in den meisten Faellen eine Verringerung der Fehlalarme und eine Erhoehung der Erkennungsrate erreichen.\cite{IDSTHREADGRIMMER2021}


        Data-flow (parameters) und code-path-flow kombinieren (sequenz).


    \subsection{LSTM/RNNs für HIDS mit System Calls}
        Überblick~\cite{NLPHIDSSWORNA2022}
        NLP Dinge auch Transformer
        \begin{itemize}
            \item contextual word embedding tecniques biderectional encoder representations from Transformers (BERT)~\cite{NLPBERT2018}
            \item semantics~\cite{SEMANTICSLAKSHMANAN2015}
            \item semantics~\cite{SEMANTICSCREECH2014}
            \item Word2Vec~\cite{W2VWUNDERLICH2019}
            \item impact of embedding~\cite{IMPACTOFEMBEDDINGWUNDERLICH2020}
        \end{itemize}
        RNN und LSTMs
        \begin{itemize}
            \item RNN~\cite{RNN/CNN}
            \item LSTM1~\cite{LSTMsys}
            \item LSTM2~\cite{LSTMSURATKAR2019} 
            \item LSTM3~\cite{NIU2020} 
            \item LSTM4~\cite{BIDIRECTIONALLSTMCHAWLA2019} 
            \item LSTM5~\cite{VARIATIONALLSTMBOUZAR2019} 
            \item LSTM6~\cite{RNNVEDBOUZAR2020} 
            \item LSTM trained with malicious and bening data~\cite{LSTMKIM2016} % 33
            \item LSTM as EDR with events~\cite{EVENTLSTMVASQUEZ2020}
            \item LSTM in Industrial Control System ICS~\cite{ICSLSTMFENG2017} % 34
            \item LSTM uusing system logs~\cite{LOGLSTMMIN2017} %35
            
            \item weiteres
        \end{itemize}

    \subsection{NLP in der Anomaliedetektion und HIDS}

        \subsection{Vorverarbeitung}

        \subsection{Algorithmik}

        \paragraph{RNN}

        \paragraph{LSTM}

        2016 Kim~\cite{LSTMsys} 

        2017 Dymshits~\cite{LSTMDYMSHITS2017} supervising multiple hosts
        normalized bag of system calls, sehr großes embedding (ca. 300), Vektor von integers für festes Zeitfenster (z.B. 1sec)



