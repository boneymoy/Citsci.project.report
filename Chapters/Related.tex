%*****************************************
\chapter{Verwandte Arbeiten}\label{ch:verwandte_arbeiten}
%*****************************************

Die Forschungsfrage mit der sich diese Arbeit beschäftigt kann wie in~\autoref{sec:Forschungsfrage} beschrieben kann weiter unterteilt werden.
Zum einen soll untersucht werden inwiefern \ac{LSTM} neuronale Netze in anomaliebasierten \ac{HIDS} Vorteile bringen können.
Und zum anderen wie durch die Anreicherung der Sequenzen von System Calls, durch weitere Informationen neben dem Namen des System Calls, die \ac{FP}-Rate verbessert werden kann.
Um den Überblick über die verwandten Arbeiten nicht zu verlieren sind diese im Folgenden untergliedert.
Zunächst sollen Grundlagen der Anomalieerkennung und erste Ansätze der Anomalieerkennung mit System Calls aufgeführt werden, auf welchen diese Arbeit indirekt fußt.
Im nächsten Schritt werden dann Arbeiten betrachtet, welche speziell die System Call Sequenzen anreichern.
Abschließend werden Arbeiten untersucht welche sich speziell mit dem Einsatz von \ac{RNN} und \ac{LSTM} Netzwerken auseinandersetzen.

\section{Anomaliedetektion}

    Anomaliedetektion wird in vielen Bereichen eingesetzt.
    % Dazu gehören die Erkennung von Betrug, unter anderem bei Kreditkarten~\cite{CREDITBOLTON2001}, das Aufdecken von Unregelmäßigkeiten in medizinischen und Gesundheitsdaten~\cite{MEDIZINHORN2001} oder Schadenserkennung in der Industrie~\cite{INDUSTRIEBASU2007}.
    Die Anfänge der Anomalieerkennug wird von~\cite{ANOMALYBOOKKISHAN2017} auf die Arbeit von~\cite{ANOMALYDEFINITION1969} zurückgeführt, in welcher sogenannte Ausreißer in Sample-Daten gefunden und entfernt werden sollen.
    Hingegen berufen sich~\cite{ANOMALYSURVEY} bei den Anfängen der Anomalieerkennung auf eine Arbeit aus dem~\textit{Dublin Philosophical Magazine of Journal and Science} von 1887~\cite{ANOMALYDEFINITION1887}.
    Dort werden \textit{discordant observations}\marginpar{zu dt.\ nicht stimmige Beobachtung} anhand einer abweichenden gesetzmäßigen Frequenz isoliert. 
    Speziell im Kontext der Angriffserkennung wird wie in~\autoref{sec:Datenerfassung} beschrieben die Anomalieerkennung in \ac{NIDS} und \ac{HIDS} eingeteilt.
    Da es wie in der Anomalieerkennung in diesen Bereichen eine große Anzahl an Arbeiten und auch Übersichtsarbeiten gibt~\cite{ANOMALYSURVEY, ANOMALYSURVEY3}, soll im Folgenden nur auf bestehende Arbeiten im Bereich der \ac{HIDS} eingegangen werden, welche speziell System Calls verwenden.

    \subsection{Anomaliedetektion mit System Calls}

    \paragraph{Sequenzen}
        Bereits 1996 stellten Stephanie Forrest et al.~\cite{FORREST} die erste Arbeit vor in welcher sie mit ihrem \ac{TIDE} Algorithmus Anomalien in System Call Daten ermitteln.
        Dabei wird anhand einer Datenbank gültiger System Call Paare, \textit{lookahead pairs}, ermittelt ob eine System Call Sequenz eine Anomalie darstellt.

        In einer späteren Arbeit erweitern sie diesen Ansatz, indem sie die Datenbank mit zusammenhängende Sequenzen von System Calls befüllen.
        Kommt eine Sequenz nicht in der Datenbank vor wird diese als Anomalie eingestuft, so wird \ac{TIDE} zu \ac{STIDE}.~\cite{STIDE}

        Ein anderen Ansatz wählten 1997 Lee et al.~\cite{LEE1997}, wobei sie sich auch auf die Pionierarbeit von~\cite{FORREST} berufen.
        Sie versuchen mit dem \ac{ML}-Programm \ac{RIPPER} Regeln in den System Call Daten zu lernen~\cite{LEE1997}
        Im Gegensatz zu~\cite{FORREST} werden bei diesem Ansatz normale sowie anormale Sequenzen gelernt.

        1999 untersuchten Warrender et al.\ wie verschiedene Algorithmen auf System Call Daten abschneiden.
        Dazu gehören die bereits erwähnten Verfahren \ac{TIDE}, \ac{STIDE}, \ac{RIPPER}, sowie ein \ac{HMM}.
        Dabei schienen alle Verfahren erfolgreich wobei das \ac{HMM} als sehr rechenintensiv hervorgehoben wird.
        Speziell interessant an dieser Arbeit ist auch die Verwendung von n-grammen aus der Textverarbeitung.~\cite{STIDE_Alternatives}
 
        % Auch in moderneren Arbeiten werden die Abfolge von System Calls beziehungsweise speziell nur die Funktionsnamen verwendet.
        Auch aktuellere Arbeiten befassen sich mit der Anomalieerkennung mit System Calls, {\color{red} speziell nur Namen von System Calls}.
    
        2005 betrachten Kang et al.\ nicht die Sequenzen sondern auf die Frequenzen der auftretenden System Calls.
        Dabei zählen sie das Auftreten von System Calls in einem bestimmten Zeitfenster und verwenden dann die sogenannten \textit{bag of system calls}\marginpar{zu dt. Bündel von Systemaufrufen} für ihre Beschreibung des Normalverhaltens.
        Ähnlich zu~\cite{FORREST} und~\cite{STIDE} bauen sie mit diesen Bündelungen eine Datenbank für das Normalverhalten auf.~\cite{FREQUENCY2}

        2013 stellen Murtaza et al. System Calls als Zustände von Kernelmodulen dar, indem sie System Calls einem bestimmten Modul zuschreiben.
        Dazu gehört zum Beispiel das Modul \textit{File System} mit den System Calls \textit{read} \textit{write} etc., oder auch \textit{Architecture}, \textit{Memory Management}.
        Der Wahrscheinlichkeiten für das Auftreten von Zustandssequenzen wird dann zur Identifizierung von Anomalien genutzt.~\cite{SYSTEM_STATES}

        2018 interpretieren Grimmer et al. System Call Sequenzen als einen sogenannten \textit{System Call Graph}.
        Dabei werden wie in~\cite{STIDE_Alternatives} ngramme verwendet.
        Die N-gramme stellen einen Knoten dar und der Übergang eines N-gramms zu einem weiteren wird mit einer gerichteten Kante dargestellt.
        Zusammen mit den Häufigkeiten des Auftretens eines Überganges und dem Ausgangsgrad eines Knotens ergeben sich dann Übergangswahrscheinlichkeiten, für alle Knoten.
        Der Anomaliescore wird dann anhand der Übergangswahrscheinlichkeiten aus dem im Training aufgebauten Graphen abgelesen.~\cite{SYSCALL_GRAPHS} 

        % (2015) Einsatz in Linux Containern~\cite{FREQUENCY1} oder (2018) in Cloud Lösungen~\cite{VM}

    Doch es gibt auch mehrere Arbeiten die Schwachstellen der Angriffserkennung mittels Sequenzen von System Calls aufzeigen.
    % Zumindest sofern nur die Sequenz der System Calls betrachtet wird.
    In~\cite{Syscallseqexploit1} werden verschieden Methoden untersucht mit welchen Angriffe nicht durch das IDS von~\cite{FORREST2000}\marginpar{beruht auf \ac{STIDE}~\cite{STIDE}} erkannt wurden.
    Bei ihren theoretischen Ansätzen berufen sie sich unter anderem auf das Abändern von System Call Argumenten, ohne dabei auf die Sequenz der System Calls einfluss zu nehmen.
    Und~\cite{Syscallseqexploit3} untersuchen speziell die von~\cite{FORREST} ins Spiel gebrachte Fensterlänge von $6$ für den \ac{STIDE} Algorithmus.
    Dabei umgehen sie die Angriffserkennung in dem sie die Angriffssequenzen auseinanderziehen und mit Normalsequenzen auffüllen

    Deswegen kann es entscheidend sein auch die Argumente der System Calls zu untersuchen.
    Dies zeigt, dass es sinnvoll sein kann auch noch weitere Informationen welche in den System Calls enthalten sind einzubinden.
    Seien es Metadaten wie die Thread Informationen der System Calls, oder auch die eigentlichen Argumente der Aufrufe.
    Inwiefern diese zusätzlichen Informationen bereits in der Literatur verwendet wurde soll nun behandelt werden.

    \paragraph{Mehr als Sequenzen}

        (2003/2006) System Call Argumente:~\cite{ARGUMENTS, ARGUMENTS2} erkennen diese Problematik an und versuchen Argumente der System Calls einzubinden.
        Generell ist dabei die Grundidee die Kodierung eines System Calls um die Kodierung der jeweiligen Argumente zu erweitern.
        Dazu gehören String Länge: Annahmen über Verteilung von String Längen der Argumente. 
            Berechnen von Sample mean und Sample Varianz der String Längen von System Calls und mit Chebychev Distance Anomaliescore angeben.
        String Charakter Verteilung: Frequenzen von Zeichen untersuchen. Lernen für jedes Argument.
        \textit{Structural Inference:} aus /usr/lib/libc.so wird /aaa/aaa/aaa.aa -> /a/a/a.a  
        Token finder: Es soll ermittelt werden ob die Werte eines bestimmten System Call Arguments aus einer endlichen Menge von Werten aus dem Trainingsdaten stammt.
        
        Diese wurden auch in die LibAnomaly library eingebunden.\
        library to implement anomaly detection models.
        Und wird auch von~\cite{MAGGI} verwendet.

        Nutzen von Thread Information~\cite{IDSTHREADGRIMMER2021}.

        Clustern von System Call Argumenten für jeden System Call~\cite{}

        Data-flow (parameters) und code-path-flow kombinieren (sequenz).


    \subsection{LSTM/RNNs für HIDS mit System Calls}
        Überblick~\cite{NLPHIDSSWORNA2022}
        NLP Dinge auch Transformer
        \begin{itemize}
            \item contextual word embedding tecniques biderectional encoder representations from Transformers (BERT)~\cite{NLPBERT2018}
            \item semantics~\cite{SEMANTICSLAKSHMANAN2015}
            \item semantics~\cite{SEMANTICSCREECH2014}
            \item Word2Vec~\cite{W2VWUNDERLICH2019}
            \item impact of embedding~\cite{IMPACTOFEMBEDDINGWUNDERLICH2020}
        \end{itemize}
        RNN und LSTMs
        \begin{itemize}
            \item RNN~\cite{RNN/CNN}
            \item LSTM1~\cite{LSTMsys}
            \item LSTM2~\cite{LSTMSURATKAR2019} 
            \item LSTM3~\cite{NIU2020} 
            \item LSTM4~\cite{BIDIRECTIONALLSTMCHAWLA2019} 
            \item LSTM5~\cite{VARIATIONALLSTMBOUZAR2019} 
            \item LSTM6~\cite{RNNVEDBOUZAR2020} 
            \item LSTM trained with malicious and bening data~\cite{LSTMKIM2016} % 33
            \item LSTM as EDR with events~\cite{EVENTLSTMVASQUEZ2020}
            \item LSTM in Industrial Control System ICS~\cite{ICSLSTMFENG2017} % 34
            \item LSTM uusing system logs~\cite{LOGLSTMMIN2017} %35
            
            \item weiteres
        \end{itemize}

    \subsection{NLP in der Anomaliedetektion und HIDS}

        \subsection{Vorverarbeitung}

        \subsection{Algorithmik}

        \paragraph{RNN}

        \paragraph{LSTM}

        2016 Kim~\cite{LSTMsys} 

        2017 Dymshits~\cite{LSTMDYMSHITS2017} supervising multiple hosts
        normalized bag of system calls, sehr großes embedding (ca. 300), Vektor von integers für festes Zeitfenster (z.B. 1sec)



